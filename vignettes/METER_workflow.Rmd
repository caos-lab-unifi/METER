---
title: "Getting started with METER workflow"
author: "Marta Paoli"
date: "2024-04-10"
output:
  html_document:
    number_sections: yes
    toc: yes
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# METER tutorial {-}
METER (METhylation analyzER) is a computational tool to analyze TC exploiting iDMS and iDMR in lpWGBS data of cfDNA samples.
It comprises three modules:

* **METER-quant** to measure circulating tumor DNA (ctDNA), based on tumor-specific iDMS

*  **METER-detect** to classify samples as ctDNA+ or ctDNA- (that is ctDNA is detected or not), based on tumor-specific iDMR

*  **METER-subtype** to infer specific subtype from ctDNA, based on tumor subtype-specific iDMR

Each module relies on task-specific informative iDMR and iDMS identified through the differential analysis between DNA-methylation data from tumor-type specific tissue samples and control samples such as cell-free DNA (cfDNA) samples from healthy donors or whole blood.

The package includes also a set of functions for computing useful statistics to select iDMS or iDMR, starting from a data frame reporting chromosomal and genomic position of each CpG site or region, and two beta tables from two groups for comparison, such as tumors versus controls or tumor subtype 1 versus tumor subtype 2. 


```{r, functions, echo=FALSE, message=FALSE}

source('/projects/packages/METER/R/create_read_table.R')
source('/projects/packages/METER/R/filter_cov_alpha100.R')
source('/projects/packages/METER/R/create_dms_beta_table.R')
source('/projects/packages/METER/R/create_dmr_beta_table.R')
source('/projects/packages/METER/R/meter_quant_PTS.R')
source('/projects/packages/METER/R/meter_detect_PTR.R')

```


# METER-quant
In this module, the “proportion of tumor-like sites” (PTS) by sample is measured from lpWGBS as a proxy of sample’s TC. PTS for each sample is computed as the ratio of fully methylated (beta=100%) hypermethylated or fully unmethylated (beta=0%) hypomethylated iDMS to the total fully methylated/unmethylated iDMS covered. To minimize the effect of bisulfite conversion errors and increase signal specificity, only reads with alpha value of 100%, that is reads showing only methylated or unmethylated CpG sites, and covering a minimum number of CpG sites (6 CpG sites by default) are considered for the computation of the beta values.

## Functions:
The METER package provides a set of functions that use **Bismark "CpG_context"** files as a starting point to generate the Beta Table necessary for computing PTS.

### create_read_dmr_table {-}
Starting from Bismark "CpG_context" file for a specific sample, this function generates a table that summarizes information for each sequencing read. 

* **Input data and parameters**:
    + cpg_file: Bismark "CpG_context" file for the sample analyzed, obtained using *--comprehensive* option (...)
    + dmr_table (optional, required for METER-detect module): a DataFrame reporting the chromosomal and genomic positions of selected iDMR, containing at least 4 columns: "dmr_id" (unique identifier for a specific iDMR), "chr" (chromosome reported as "chr1"), "start" (starting genomic position), "end" (ending genomic position), and "type" ("hypo" for hypomethylated iDMR or "hyper" for hypermethylated iDMR). A data frame listing breast cancer-specific iDMR for tumor content detection is included within METER package.
    
* **Output**:
    + Read Table: a DataFrame containing summarized information for each sequencing read, including the position of the first CpG site within the read ("min_cpg_pos"), the position of the last CpG within the read ("max_cpg_pos"), the number of methylated CpGs ("n_meth"), the number of unmethylated CpGs ("n_unmeth"), and the total number of CpGs covered ("n_sites"). Additionally, if an iDMR Table is provided, it specifies, for each read, the overlapping iDMR ("dmr_id") and the type of the overlapping iDMR ("hypo" or "hyper"), where "overlapping" means the read is entirely contained within an iDMR.

Note1: this step takes a while, so if one has a lot of samples to process parallelization is recommended when possible

Note2: the file name of the output Read Table has to be chosen by the user when saving the table, and it will serve as sample ID for subsequent steps 
  
```{r, create_read_dmr_table}
path_cpg_files='/projects/packages/METER/data/bismark/all_chr/'
path_out='/projects/packages/METER/toy_out/create_read_dmr_table_noDMR/'

dir.create(path_out, showWarnings = F, recursive = T)

cpg_files=list.files(path_cpg_files, full.names = T, pattern = 'CpG_context')

# i=cpg_files[1]
parallel::mclapply(cpg_files, function(i){

  samp_id=gsub('CpG_context_', '', strsplit(basename(i), "_1_val_1", fixed = T)[[1]][1])
  samp_id=gsub('CpG_context_', '', strsplit(samp_id, ".R1_val_1", fixed = T)[[1]][1])
  
  # tictoc::tic()
  read_table=create_read_table(path_cpg_file = i)
  # tictoc::toc()
  
  saveRDS(read_table, file.path(path_out, paste0(samp_id, '.rds')))

  }, mc.cores = 6)

rm(list = ls())


### take a look to one of the tables created
example_table=readRDS('/projects/packages/METER/toy_out/create_read_dmr_table_noDMR/A001T0.rds')
head(example_table)

```

    
### filter_cov_alpha100 {-}
Starting from Bismark "CpG_context" file and the Read Table from the previous step for a particular sample, this function creates a filtered "Bismark-like CpG_context" file, considering only reads with an alpha value of 100% (besed on the Read Table) and covering a minimum number of CpGs (6 by default). Subsequently, it employes the *bismark2bedGraph* function from Bismark to produce the corresponding coverage file (".cov"), displaying, for each CpG, the count of methylated/unmethylated reads covering its position.

* **Input data and parameters**:
    + path_bismark2bedGraph: absolute path to *bismark2bedGraph* function
    + path_cpg_file: absolute path to Bismark "CpG_context" file for the sample analyzed, obtained using *--comprehensive* option (...)
    + path_read_table: absolute path to Read Table previously generated
    + path_out (optional): absolute path to output folder
    + min_sites (default min_sites=6): integer indicating the minimum number of CpGs a read should contain in order to be considered in the filtered "CpG_context" file and consequently in the filtered "coverage file"
    + remove_cpg (default remove_cpg=FALSE): TRUE if one wants to delete intermediate "CpG_context" file once the final "coverage file" has been created
    
* **Output**:
    + "Coverage file" generated by *bismark2bedGraph* function from Bismark, constructed considering only reads with alpha value of 100%.
    
Note3: The file name of the output .cov file derives from the base name of the input Read Table (generated in the preceding step) that has been chosen by the user  
    
```{r}
path_read_tables='/projects/packages/METER/toy_out/create_read_dmr_table_noDMR/'
path_cpg_files='/projects/packages/METER/data/bismark/all_chr/'
path_bis='/home/marta.paoli/bismark/Bismark-0.23.1/bismark2bedGraph'
out_folder='/projects/packages/METER/toy_out/filter_cov_alpha100/'

dir.create(out_folder, showWarnings = F, recursive = T)

### CpG files (output of bismark methylation extractor using --comprehensive option)
cpg_files=list.files(path_cpg_files, full.names = T, pattern = '^CpG_context*')

### bismark reads summary tables
read_tables=list.files(path_read_tables, full.names = T, pattern = '.rds')

### run filter_cov_alpha100 function on all input samples
# i=read_tables[1]
parallel::mclapply(read_tables, function(i){

  id=gsub('.rds', '', basename(i), fixed = T)

  path_cpg=cpg_files[which(grepl(id, cpg_files))]

  filter_cov_alpha100(path_bismark2bedGraph = path_bis, path_cpg_file = path_cpg, path_read_table = i, path_out = out_folder, remove_cpg = F)

}, mc.cores = 1)

```

    
### create_dms_beta_table {-}
This function computes beta values (proportions) of selected iDMS for each sample, and creates a DataFrame with samples as column names and CpG sites as row names. The computation of beta values is performed using the "coverage files" generated in the previous step.

* **Input data and parameters**:
    + dms_table:  DataFrame reporting the chromosomal and genomic positions of selected iDMS, containing at least 4 columns: "dms_id" (unique identifier for a specific iDMS), "chr" (chromosome reported as "chr1"), "pos" (genomic position), and "type" ("hypo" for hypomethylated CpG or "hyper" for hypermethylated CpG). A data frame listing breast cancer-specific iDMS for tumor content quantification is included within METER package.
    + path_cov_files: absolute path to the folder that contains all the "coverage files" created for each sample in the previous step.
    + id_pattern (optional): string used as input for the R strsplit() function to extract the names of samples from the base names of the input "coverage files". If nothing is provided, the samples' names are derived from the base names of the input "coverage files".

* **Output**:
    + Beta Table: a DataFrame containing beta values (proportions) of iDMS across samples, with samples as column names and iDMS as row names. Each iDMS is reported with its unique "dms_id", matching the identifiers provided in the iDMS table. Beta values are computed considering only reads with alpha value of 100% and covering a minimum number of CpGs, as explained above.

```{r}
path_cov_files='/projects/packages/METER/R/toy_out/data_processing/filter_cov_alpha100/'
path_dmss='/projects/packages/METER/R/toy_input/dmr_dms_tables/dms_filtered.rds'
path_out='/projects/packages/METER/R/toy_out/data_processing/'

dmss=readRDS(path_dmss)
head(dmss)

dms_beta_tab=create_dms_beta_table(dms_table = dmss, path_cov_files = path_cov_files, id_pattern = '.gz.bismark.cov.gz')

head(dms_beta_tab)

saveRDS(object = dms_beta_tab, file = file.path(path_out, 'dms_beta.rds'))


```

### meter_quant_PTS {-}
computes PTS for each sample and creates a summary table

* **Input data and parameters**:
    + dms_table: a DataFrame reporting the chromosomal and genomic positions of selected iDMS, containing at least 4 columns: "dms_id" (unique identifier for a specific iDMS), "chr" (chromosome reported as "chr1"), "pos" (genomic position), and "type" ("hypo" for hypomethylated CpG or "hyper" for hypermethylated CpG). A data frame listing breast cancer-specific iDMS for tumor content quantification is included within METER package.
    + beta_table: a DataFrame containing beta values (proportions) of CpG sites across samples, with samples as column names and CpG sites as row names. Each CpG site must be reported with its unique "dms_id", matching the identifiers provided in the iDMS table. Beta values should be computed considering only reads with alpha value of 100% and covering a minimum number of CpGs, as explained above.
    
* **Output**:
    + PTS Table: a DataFrame that includes PTS values for hypermethylated iDMS (PTS_hyper), hypomethylated iDMS (PTS_hypo), and both hyper and hypomethylated iDMS combined (PTS_all) for each sample. PTS_all measure can be used as a proxy of TC.


```{r}
path_dmss='/projects/packages/METER/R/toy_input/dmr_dms_tables/dms_filtered.rds'
path_dms_beta='/projects/packages/METER/R/toy_out/data_processing/dms_beta.rds'
path_out='/projects/packages/METER/R/toy_out/METER_quant'

dir.create(path_out, showWarnings = F)

dmss=readRDS(path_dmss)
dms_beta=readRDS(path_dms_beta)

head(dmss)
head(dms_beta[, 1:2])

pts_tab=meter_quant_PTS(dms_table = dmss, beta_table = dms_beta)

head(pts_tab)

saveRDS(pts_tab, file.path(path_out, 'pts_table.rds'))

```
    
    
## Functions for data processing:



# METER-detect
In this module, the "proportion of tumor-like sequenced reads" (PTR) is computed from lpWGBS data for each sample, and a z-score approach, based on the distribution of this measure in control samples (reference model), is then used to classify samples as either ctDNA positive (METER+) or ctDNA negative (METER-). Only reads with alpha value of 100%, that is reads exhibiting only methylated or unmethylated CpGs, and covering a minimum number of CpGs are considered for PTR computation. Specifically, PTR for each sample is computed as the proportion of fully methylated or unmethylated reads within selected hyper- or hypo- iDMR respectively, over the total reads with alpha=100%. 

## Main functions:

### meter_detect_PTR {-}
computes PTR for each sample and creates a summary table

* **Input data and parameters**:
    + path_read_tables: absolute path to the folder containing all the Read Tables created for each sample using *create_read_dmr_table* function (see METER-quant section).
    + min_sites (default min_sites=6): integer indicating the minimum number of CpGs a read should contain in order to be considered for PTR computation
    + ncores (default ncores=1): integer value representing the number of processor cores to use for parallel processing of samples.
    
* **Output**:
    + PTR Table: a DataFrame containing PTR values for hypermethylated iDMR (PTR_hyper), hypomethylated iDMR (PTR_hypo), and both hyper and hypomethylated iDMR combined (PTR_all) for each sample. Using this DataFrame, each sample can be classified as ctDNA-positive (METER+) if its Z-score exceeds a certain threshold. For breast cancer samples, Z-scores thresholds based on the distribution of PTR in control samples (reference model) are provided within METER package. 
    
```{r}
path_read_tabs='/projects/packages/METER/R/toy_out/data_processing/create_read_dmr_table_v2/'
path_out='/projects/packages/METER/R/toy_out/METER_detect'

dir.create(path_out, showWarnings = F)

ptr_tab=meter_detect_PTR(path_read_tables = path_read_tabs, min_sites = 6, ncores = 4)

head(ptr_tab)

saveRDS(ptr_tab, file.path(path_out, 'ptr_table.rds'))

```

    
## Functions for data processing:
The METER package provides a set of functions that use Bismark "CpG_context" files as a starting point to generate the Read Tables necessary for computing PTR.

### create_read_dmr_table {-}
As outlined in the METER-quant section, this function utilizes a Bismark "CpG_context" file for a specific sample to generate a comprehensive table summarizing information for each sequencing read. In detail, it creates a DataFrame containing for each read the position of the first CpG site within the read ("min_cpg_pos"), the position of the last CpG within the read ("max_cpg_pos"), the number of methylated CpGs ("n_meth"), the number of unmethylated CpGs ("n_unmeth"), and the total number of CpGs covered ("n_sites"). Importantly, this module requires the iDMR Table to be provided. This allows the function to evaluate, for each read, the overlapping iDMR ("dmr_id") and the type of the overlapping iDMR ("hypo" or "hyper"), where "overlapping" means the read is entirely contained within an iDMR. (See METER-quant module for details)

```{r, create_read_dmr_table_v2}
# path_cpg_files='/projects/packages/METER/R/toy_input/bismark/'
# path_dmrs='/projects/packages/METER/R/toy_input/dmr_dms_tables/dmr_filtered.rds'
# path_out='/projects/packages/METER/R/toy_out/data_processing/create_read_dmr_table_v2/'
# 
# dir.create(path_out, showWarnings = F, recursive = T)
# 
# cpg_files=list.files(path_cpg_files, full.names = T, pattern = 'CpG_context')
# 
# dmrs=readRDS(path_dmrs)
# head(dmrs)
# 
# # i=cpg_files[1]
# parallel::mclapply(cpg_files, function(i){
#   
#   samp_id=gsub('CpG_context_', '', strsplit(basename(i), "_1_val_1", fixed = T)[[1]][1])
# 
#   read_table=create_read_dmr_table(cpg_file = i, dmr_table = dmrs)
# 
#   saveRDS(read_table, file.path(path_out, paste0(samp_id, '.rds')))
# 
#   }, mc.cores = 4)


### take a look to one of the tables created
example_table=readRDS('/projects/packages/METER/R/toy_out/data_processing/create_read_dmr_table_v2/MS05_T1.rds')
head(example_table)

```




# METER-subtype
This module employes the Robust Partial Correlation (RPC) deconvolution method, as implemented in the EpiDISH R package, to evaluate tumor subtype in circulation. For this method, a reference model is necessary, which is derived by computing the median beta value for each selected iDMR across reference samples representing the components to be deconvoluted. Naturally, it is crucial that the iDMRs included in the reference model are subtype-specific, meaning they should exhibit differential methylation between tumor subtype 1 and tumor subtype 2, as well as between tumor and healthy cfDNA (details for selecting such DMRs are provided in the section..). Additionally, the RPC method requires a beta table containing beta values for each selected iDMR across all samples being analyzed. For breast cancer samples, the METER package provides a reference model including ER+, ER-, and healthy cfDNA components for 1605 subtype-specific iDMRs.

## Functions for data processing: 

### create_dmr_beta_table
This function computes beta by DMR values (proportions) of selected iDMR for each sample, and creates a DataFrame with samples as column names and iDMR as row names. Beta by DMR values are computed as the mean beta values of CpG sites within the specific DMR, starting from Bismark "coverage files".

* **Input data and parameters**:
    + dmr_table: a DataFrame reporting the chromosomal and genomic positions of selected iDMR, containing at least 4 columns: "dmr_id" (unique identifier for a specific iDMR), "chr" (chromosome reported as "chr1"), "start" (starting genomic position), "end" (ending genomic position), and "type" ("hypo" for hypomethylated iDMR or "hyper" for hypermethylated iDMR). A data frame listing breast cancer-specific iDMR for tumor content detection is included within METER package.
    + path_cov_files: absolute path to the folder that contains all Bismark "coverage files" for each sample.
    + id_pattern (optional): string pattern used as input for the R strsplit() function to extract th names of samples from the filenames of the input "coverage files". If nothing is provided, the samples' names are derived from the base names of the input "coverage files".
    + min_sites (default min_sites=0): integer number indicating the minimum number of CpGs a DMR has to comprise for a specific sample so that its beta value for the specific sample will be reported in the final table.

* **Output**:
    + Beta Table: a DataFrame containing beta by DMR values (proportions) of iDMR across samples, with samples as column names and iDMR as row names. Each iDMR is reported with its unique "dmr_id", matching the identifiers provided in the iDMR table.
    
Note1: in this step it is not necessary to consider reads with alpha value of 100% only to compute beta by DMR, therefore the following example utilizes Bismark "coverage files" considering all sequenced reads.

Note2: in this deconvolution step it is recommended to consider the beta of a specific DMR for a specific sample when the specific DMR for the specific sample covers a minimum number of CpGs, so that the beta computed is reliable 

```{r}
path_cov_files='/projects/packages/METER/R/toy_input/bismark/'
path_dmrs='/projects/packages/METER/R/toy_input/dmr_dms_tables/dmr_filtered_subtype.rds'
path_out='/projects/packages/METER/R/toy_out/data_processing/'


dmrs=readRDS(path_dmrs)
head(dmrs)

dmr_beta=create_dmr_beta_table(dmr_table = dmrs, path_cov_files = path_cov_files, id_pattern = '_1_val_1', min_sites = 10)

head(dmr_beta)

saveRDS(object = dmr_beta, file = file.path(path_out, 'dmr_beta_subtype.rds'))

```
    
Once the DMR Beta Table of lpWGBS samples has been generated one can perform the deconvolution step with EpiDISH (...)
    
```{r}
path_median_ref='/projects/packages/METER/R/toy_input/erpos_erneg_ref.rds'
path_dmr_beta='/projects/packages/METER/R/toy_out/data_processing/dmr_beta_subtype.rds'
path_out='/projects/packages/METER/R/toy_out/METER_subtype/'

dir.create(path_out, showWarnings = F)

median_ref=readRDS(path_median_ref)
dmr_beta=readRDS(path_dmr_beta)

common_dmr=intersect(median_ref$region_hg38, rownames(dmr_beta))

rownames(median_ref) = median_ref$region_hg38
median_ref=median_ref[, c("median_ERpos", "median_ERneg", "median_hcfDNA")]
median_ref=median_ref[common_dmr, ]
median_ref=median_ref/100
colnames(median_ref) = gsub('median_', '', colnames(median_ref))

dmr_beta=dmr_beta[common_dmr, ]

median_ref=median_ref[order(row.names(median_ref)), ]
dmr_beta=dmr_beta[order(row.names(dmr_beta)), ]

head(median_ref)
head(dmr_beta)

assertthat::assert_that(all.equal(rownames(median_ref), rownames(dmr_beta)))
assertthat::assert_that(is.numeric(median_ref$ERpos))
assertthat::assert_that(is.numeric(dmr_beta$MS05_T1))

median_ref=as.matrix(median_ref)
dmr_beta=as.matrix(dmr_beta)

### Run EpiDISH
out_epidish=EpiDISH::epidish(beta.m = dmr_beta, ref.m = median_ref, method = "RPC")$estF

out_epidish=as.data.frame(out_epidish)
head(out_epidish)

out_epidish$er_status_pred=dplyr::case_when(
  out_epidish$hcfDNA==1 ~ 'hcfDNA',
  out_epidish$ERpos>=out_epidish$ERneg ~ 'ERpos',
  out_epidish$ERpos<out_epidish$ERneg ~ 'ERneg'
)

table(out_epidish$er_status_pred, useNA = 'always')

saveRDS(out_epidish, file.path(path_out, 'RPC_components.rds'))

```
