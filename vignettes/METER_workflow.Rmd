---
title: "Getting started with METER workflow"
author: "Marta Paoli"
date: "April 2024"
output:
  html_document:
    number_sections: yes
    toc: yes
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# METER tutorial {-}
METER (METhylation analyzER) is a computational tool to analyze TC exploiting iDMS and iDMR in lpWGBS data of cfDNA samples.
It comprises three modules:

* **METER-quant** to measure circulating tumor DNA (ctDNA), based on tumor-specific iDMS

*  **METER-detect** to classify samples as ctDNA+ or ctDNA- (that is ctDNA is detected or not), based on tumor-specific iDMR

*  **METER-subtype** to infer specific subtype from ctDNA, based on tumor subtype-specific iDMR

Each module relies on task-specific informative iDMR and iDMS identified through the differential analysis between DNA-methylation data from tumor-type specific tissue samples and control samples such as cell-free DNA (cfDNA) samples from healthy donors or whole blood.


```{r, echo=FALSE, message=FALSE}

devtools::load_all()


```


# METER-quant
In this module, the “proportion of tumor-like sites” (PTS) by sample is measured from lpWGBS as a proxy of sample’s TC. PTS for each sample is computed as the ratio of **fully methylated (beta=100%) hypermethylated** or **fully unmethylated (beta=0%) hypomethylated** **iDMS** (that is DMS supporting a tumor-like methylation signal) to the total fully methylated/unmethylated iDMS covered. To minimize the effect of bisulfite conversion errors and increase signal specificity, only reads with alpha value of 100%, that is reads showing only methylated or unmethylated CpG sites, and covering a minimum number of CpG sites (6 CpG sites by default) are considered for the computation of the beta values.

## Functions:
The METER package provides a set of functions that use **Bismark "CpG_context"** files as a starting point to generate the Beta Table necessary for computing PTS.

### create_read_table {-}
Starting from Bismark "CpG_context" file for a specific sample, this function generates a table that summarizes information for each sequencing read. 

* **Input data and parameters**:
    + cpg_file: Bismark "CpG_context" file for the sample analyzed, obtained using *--comprehensive* option (...)
    + dmr_table (optional, required for METER-detect module): a DataFrame reporting the chromosomal and genomic positions of selected iDMR, containing at least 4 columns: "dmr_id" (unique identifier for a specific iDMR), "chr" (chromosome reported as "chr1"), "start" (starting genomic position), "end" (ending genomic position), and "type" ("hypo" for hypomethylated iDMR or "hyper" for hypermethylated iDMR). A data frame listing breast cancer-specific iDMR for tumor content detection is included within METER package.
    
* **Output**:
    + Read Table: a DataFrame containing summarized information for each sequencing read, including the position of the first CpG site within the read ("min_cpg_pos"), the position of the last CpG within the read ("max_cpg_pos"), the number of methylated CpGs ("n_meth"), the number of unmethylated CpGs ("n_unmeth"), and the total number of CpGs covered ("n_sites"). Additionally, if an iDMR Table is provided, it specifies, for each read, the overlapping iDMR ("dmr_id") and the type of the overlapping iDMR ("hypo" or "hyper"), where "overlapping" means the read is entirely contained within an iDMR.

Note: this step takes a while, so if one has a lot of samples to process parallelization is recommended when possible

Note: the file name of the output Read Table has to be chosen by the user when saving the table, and it will serve as sample ID for subsequent steps 
  
```{r}
path_cpg_files='/home/marta.paoli/packages/METER/data/Bismark/'
path_out='/home/marta.paoli/packages/METER/toy_out/create_read_table_noDMR/'

dir.create(path_out, showWarnings = F, recursive = T)

cpg_files=list.files(path_cpg_files, full.names = T, pattern = 'CpG_context')

# i=cpg_files[1]
parallel::mclapply(cpg_files, function(i){

  samp_id=gsub('CpG_context_', '', strsplit(basename(i), "_bismark_", fixed = T)[[1]][1])

  read_table=create_read_table(path_cpg_file = i)

  saveRDS(read_table, file.path(path_out, paste0(samp_id, '.rds')))

  }, mc.cores = 6)

rm(list = ls())


### take a look to one of the tables created
example_table=readRDS('/home/marta.paoli/packages/METER/toy_out/create_read_table_noDMR/samp1.rds')
head(example_table)

```

    
### filter_cov_alpha100 {-}
Starting from Bismark "CpG_context" file and the Read Table from the previous step for a particular sample, this function creates a filtered "Bismark-like CpG_context" file, considering only reads with an alpha value of 100% (besed on the Read Table) and covering a minimum number of CpGs (6 by default). Subsequently, it employes the *bismark2bedGraph* function from Bismark to produce the corresponding coverage file (".cov"), displaying, for each CpG, the count of methylated/unmethylated reads covering its position.

* **Input data and parameters**:
    + path_bismark2bedGraph: absolute path to *bismark2bedGraph* function
    + path_cpg_file: absolute path to Bismark "CpG_context" file for the sample analyzed, obtained using *--comprehensive* option (...)
    + path_read_table: absolute path to Read Table previously generated
    + path_out (optional): absolute path to output folder
    + min_sites (default min_sites=6): integer indicating the minimum number of CpGs a read should contain in order to be considered in the filtered "CpG_context" file and consequently in the filtered "coverage file"
    + remove_cpg (default remove_cpg=FALSE): TRUE if one wants to delete intermediate "CpG_context" file once the final "coverage file" has been created
    
* **Output**:
    + "Coverage file" generated by *bismark2bedGraph* function from Bismark, constructed considering only reads with alpha value of 100%.
    
Note: this step takes a while, so if one has a lot of samples to process parallelization is recommended when possible

Note: The file name of the output .cov file derives from the base name of the input Read Table (generated in the preceding step) that has been chosen by the user  
    
```{r}
path_read_tables='/home/marta.paoli/packages/METER/toy_out/create_read_table_noDMR/'
path_cpg_files='/home/marta.paoli/packages/METER/data/Bismark/'
path_bis='/home/marta.paoli/bismark/Bismark-0.23.1/bismark2bedGraph'
out_folder='/home/marta.paoli/packages/METER/toy_out/filter_cov_alpha100/'


### CpG files (output of bismark methylation extractor using --comprehensive option)
cpg_files=list.files(path_cpg_files, full.names = T, pattern = '^CpG_context*')

### bismark reads summary tables
read_tables=list.files(path_read_tables, full.names = T, pattern = '.rds')

### run filter_cov_alpha100 function on all input samples
# i=read_tables[1]
parallel::mclapply(read_tables, function(i){

  id=gsub('.rds', '', basename(i), fixed = T)

  path_cpg=cpg_files[which(grepl(id, cpg_files))]

  filter_cov_alpha100(path_bismark2bedGraph = path_bis, path_cpg_file = path_cpg, path_read_table = i, path_out = out_folder, remove_cpg = F)

}, mc.cores = 1)

```

    
### create_dms_beta_table {-}
This function computes beta values (proportions) of selected iDMS for each sample, and creates a DataFrame with samples as column names and CpG sites as row names. The computation of beta values is performed using the "coverage files" generated in the previous step.

* **Input data and parameters**:
    + dms_table:  DataFrame reporting the chromosomal and genomic positions of selected iDMS, containing at least 4 columns: "dms_id" (unique identifier for a specific iDMS), "chr" (chromosome reported as "chr1"), "pos" (genomic position), and "type" ("hypo" for hypomethylated CpG or "hyper" for hypermethylated CpG). A data frame listing breast cancer-specific iDMS for tumor content quantification is included within METER package.
    + path_cov_files: absolute path to the folder that contains all the "coverage files" created for each sample in the previous step.
    + id_pattern (optional): string used as input for the R strsplit() function to extract the names of samples from the base names of the input "coverage files". If nothing is provided, the samples' names are directly derived from the base names of the input "coverage files".

* **Output**:
    + Beta Table: a DataFrame containing beta values (proportions) of iDMS across samples, with samples as column names and iDMS as row names. Each iDMS is reported with its unique "dms_id", matching the identifiers provided in the iDMS table. Beta values are computed considering only reads with alpha value of 100% and covering a minimum number of CpGs, as explained above.
    
Note: Samples' IDs (column names of the output DMS beta table) are derived from the base names of the input .cov files (that in turn derive from the base names of the read tables). Bismark attaches some extensions to the .cov files generated that can be removed through the "id_pattern" parameter.

```{r}
path_cov_files='/home/marta.paoli/packages/METER/toy_out/filter_cov_alpha100/'
path_dmss='/home/marta.paoli/packages/METER/data/dmr_dms_tables/dms_filtered.rds'
path_out='/home/marta.paoli/packages/METER/toy_out/'

dmss=readRDS(path_dmss)
head(dmss)

dms_beta_tab=create_dms_beta_table(dms_table = dmss, path_cov_files = path_cov_files, id_pattern = '.gz.bismark.cov.gz')

head(dms_beta_tab)

saveRDS(object = dms_beta_tab, file = file.path(path_out, 'dms_beta.rds'))


```

### meter_quant_PTS {-}
computes PTS for each sample and creates a summary table

* **Input data and parameters**:
    + dms_table: a DataFrame reporting the chromosomal and genomic positions of selected iDMS, containing at least 4 columns: "dms_id" (unique identifier for a specific iDMS), "chr" (chromosome reported as "chr1"), "pos" (genomic position), and "type" ("hypo" for hypomethylated CpG or "hyper" for hypermethylated CpG). A data frame listing breast cancer-specific iDMS for tumor content quantification is included within METER package.
    + beta_table: a DataFrame containing beta values (proportions) of CpG sites across samples, with samples as column names and CpG sites as row names. Each CpG site must be reported with its unique "dms_id", matching the identifiers provided in the iDMS table. Beta values should be computed considering only reads with alpha value of 100% and covering a minimum number of CpGs, as explained above.
    
* **Output**:
    + PTS Table: a DataFrame that includes PTS values for hypermethylated iDMS (PTS_hyper), hypomethylated iDMS (PTS_hypo), and both hyper and hypomethylated iDMS combined (PTS_all) for each sample. PTS_all measure can be used as a proxy of TC.


```{r}
path_dmss='/home/marta.paoli/packages/METER/data/dmr_dms_tables/dms_filtered.rds'
path_dms_beta='/home/marta.paoli/packages/METER/toy_out/dms_beta.rds'
path_out='/home/marta.paoli/packages/METER/toy_out/'


dmss=readRDS(path_dmss)
dms_beta=readRDS(path_dms_beta)

head(dmss)
head(dms_beta)

pts_tab=meter_quant_PTS(dms_table = dmss, beta_table = dms_beta)

head(pts_tab)

saveRDS(pts_tab, file.path(path_out, 'meter_quant_PTS.rds'))

```
    
    

# METER-detect
In this module, the "proportion of tumor-like sequenced reads" (PTR) is computed from lpWGBS data for each sample, and a z-score approach, based on the distribution of this measure in control samples (reference model), is then used to classify samples as either ctDNA positive (METER+) or ctDNA negative (METER-). As in METER-quant module, to minimize the effect of bisulfite conversion errors and increase signal specificity, only reads with alpha value of 100% and covering a minimum number of CpGs (6 CpGs by default) are considered for PTR computation. Specifically, PTR for each sample is computed as the proportion of **fully methylated** reads within selected **hyper-iDMR** and fully **unmethylated reads** within selected **hypo-iDMR** (that is reads
supporting a tumor-like methylation signal) over the total reads with alpha=100% within selected iDMR.

## Functions:
The METER package provides a set of functions that use **Bismark "CpG_context"** files as a starting point to generate the Read Tables necessary for computing PTR.

### create_read_table {-}
As outlined in the METER-quant section, this function utilizes a Bismark "CpG_context" file for a specific sample to generate a comprehensive table summarizing information for each sequencing read. In detail, it creates a DataFrame containing for each read the position of the first CpG site within the read ("min_cpg_pos"), the position of the last CpG within the read ("max_cpg_pos"), the number of methylated CpGs ("n_meth"), the number of unmethylated CpGs ("n_unmeth"), and the total number of CpGs covered ("n_sites"). Importantly, this module requires the iDMR Table to be provided. This allows the function to evaluate, for each read, the overlapping iDMR ("dmr_id") and the type of the overlapping iDMR ("hypo" or "hyper"), where **"overlapping" means the first  and the last CpG sites within the read are both contained within an iDMR**. (See METER-quant module for details)

```{r}
path_cpg_files='/home/marta.paoli/packages/METER/data/Bismark/'
path_dmrs='/home/marta.paoli/packages/METER/data/dmr_dms_tables/dmr_filtered.rds'
path_out='/home/marta.paoli/packages/METER/toy_out/create_read_table/'


cpg_files=list.files(path_cpg_files, full.names = T, pattern = 'CpG_context')

dmrs=readRDS(path_dmrs)
head(dmrs)

# i=cpg_files[1]
parallel::mclapply(cpg_files, function(i){

  samp_id=gsub('CpG_context_', '', strsplit(basename(i), "_bismark_", fixed = T)[[1]][1])

  read_table=create_read_table(path_cpg_file = i, dmr_table = dmrs)

  saveRDS(read_table, file.path(path_out, paste0(samp_id, '.rds')))

  }, mc.cores = 6)


### take a look to one of the tables created
example_table=readRDS('/home/marta.paoli/packages/METER/toy_out/create_read_table/samp1.rds')
head(example_table)

```

### meter_detect_PTR {-}
computes PTR for each sample and creates a summary table

* **Input data and parameters**:
    + path_read_tables: absolute path to the folder containing all the Read Tables created for each sample using *create_read_table* function (see METER-quant section).
    + min_sites (default min_sites=6): integer indicating the minimum number of CpGs a read should contain in order to be considered for PTR computation
    + ncores (default ncores=1): integer value representing the number of processor cores to use for parallel processing of samples.
    
* **Output**:
    + PTR Table: a DataFrame containing PTR values for hypermethylated iDMR (PTR_hyper), hypomethylated iDMR (PTR_hypo), and both hyper and hypomethylated iDMR combined (PTR_all) for each sample. **PTR_all** measure, integrating information from bot hyper- and hypo-methylated iDMR, should be used to classify samples, specifically, using this measure, each sample can be classified as ctDNA-positive (METER+) if its Z-score exceeds a certain threshold (e.g. Z-score=3 has been used in METER study). For breast cancer samples, values corresponding to various Z-scores thresholds based on the distribution of PTR in control samples (reference model) are provided within METER package. 
    
Note: Sample ids in the "samp_id" column of the PTR Tables derive from the base name of the input Read Table files (generated in the preceding step) that have been chosen by the user  
    
    
```{r}
path_read_tabs='/home/marta.paoli/packages/METER/toy_out/create_read_table/'
path_out='/home/marta.paoli/packages/METER/toy_out/'


ptr_tab=meter_detect_PTR(path_read_tables = path_read_tabs, min_sites = 6, ncores = 4)

head(ptr_tab)

saveRDS(ptr_tab, file.path(path_out, 'meter_detect_PTR.rds'))

```

After generating the PTR Table for lpWGBS samples, **PTR_all** measure can be used to categorize samples as either ctDNA-positive or ctDNA-negative. For breast cancer samples, we can use the "PTR_z_score.rds" table available in the METER package. Specifically, the values associated with PTR_all in the "est_method" column serve as the benchmark thresholds. In the following example, a threshold corresponding to a z-sore of 3 is employed.

```{r}
path_zscore_table='/home/marta.paoli/packages/METER/data/PTR_z_scores.rds'

zscore_table=readRDS(path_zscore_table)

zscore_table

thr=zscore_table$z3[which(zscore_table$est_method=='PTR_all')]

### classify samples
ptr_tab$meter_detected=ifelse(ptr_tab$ptr_all>=thr, TRUE, FALSE)

head(ptr_tab)

```






# METER-subtype
This module employes the Robust Partial Correlation (RPC) deconvolution method, as implemented in the EpiDISH R package, to evaluate tumor subtype in circulation. For this method, a reference model is necessary, which is derived by computing the median beta value for each selected iDMR across reference samples representing the components to be deconvoluted. Naturally, it is crucial that the iDMRs included in the reference model are subtype-specific, meaning they should exhibit differential methylation between tumor subtype 1 and tumor subtype 2, as well as between tumor and healthy cfDNA (details for selecting such DMRs are provided in the section..). Additionally, the RPC method requires a beta table containing beta values for each selected iDMR across all samples being analyzed. For breast cancer samples, the METER package provides a reference model including ER+, ER-, and healthy cfDNA components for 1605 subtype-specific iDMRs.

## Functions: 

### create_dmr_beta_table
This function computes beta by DMR values (proportions) of selected iDMR for each sample, and creates a DataFrame with samples as column names and iDMR as row names. Beta values for DMRs are computed by treating all CpGs within a specific DMR collectively as a single CpG. Therefore, the beta value for each DMR is calculated based on the ratio of methylated signals to the total methylation signals for all CpGs within that DMR. In other words, it reflects the proportion of times all CpGs within the DMR are observed as methylated by sequence reads.

* **Input data and parameters**:
    + dmr_table: a DataFrame reporting the chromosomal and genomic positions of selected iDMR, containing at least 4 columns: "dmr_id" (unique identifier for a specific iDMR), "chr" (chromosome reported as "chr1"), "start" (starting genomic position), "end" (ending genomic position), and "type" ("hypo" for hypomethylated iDMR or "hyper" for hypermethylated iDMR). A data frame listing breast cancer-specific iDMR for tumor content detection is included within METER package.
    + path_cov_files: absolute path to the folder that contains all Bismark "coverage files" for each sample.
    + id_pattern (optional): string pattern used as input for the R strsplit() function to extract th names of samples from the filenames of the input "coverage files". If nothing is provided, the samples' names are derived from the base names of the input "coverage files".
    + min_sites (default min_sites=0): integer number indicating the minimum number of CpGs a DMR has to comprise for a specific sample so that its beta value for the specific sample will be reported in the final table.

* **Output**:
    + Beta Table: a DataFrame containing beta by DMR values (proportions) of iDMR across samples, with samples as column names and iDMR as row names. Each iDMR is reported with its unique "dmr_id", matching the identifiers provided in the iDMR table.
    
Note: in this step it is not necessary to consider reads with alpha value of 100% only to compute beta by DMR, therefore the following example utilizes "original" Bismark "coverage files" containing information from all sequenced reads.

Note: in this deconvolution step it is recommended to consider the beta of a specific DMR for a specific sample when the specific DMR for the specific sample covers a minimum number of CpGs, so that the beta computed is reliable (in our example we consider DMR containing a minimum of 10 CpGs per sample)

```{r}
path_cov_files='/home/marta.paoli/packages/METER/data/Bismark/'
path_dmrs='/home/marta.paoli/packages/METER/data/dmr_dms_tables/dmr_filtered_subtype.rds'
path_out='/home/marta.paoli/packages/METER/toy_out/'

dmrs=readRDS(path_dmrs)
head(dmrs)

dmr_beta=create_dmr_beta_table(dmr_table = dmrs, path_cov_files = path_cov_files, id_pattern = '_bismark_', min_sites = 10)
head(dmr_beta)

saveRDS(object = dmr_beta, file = file.path(path_out, 'dmr_beta_subtype.rds'))

```
    
Once the DMR Beta Table of lpWGBS samples has been generated one can perform the deconvolution step with EpiDISH (...)
    
```{r}
path_median_ref='/home/marta.paoli/packages/METER/data/erpos_erneg_ref.rds'
path_dmr_beta='/home/marta.paoli/packages/METER/toy_out/dmr_beta_subtype.rds'
path_out='/home/marta.paoli/packages/METER/toy_out/'

dir.create(path_out, showWarnings = F)

median_ref=readRDS(path_median_ref)
dmr_beta=readRDS(path_dmr_beta)

head(median_ref)
head(dmr_beta)

common_dmr=intersect(median_ref$region_hg38, rownames(dmr_beta))

rownames(median_ref) = median_ref$region_hg38
median_ref=median_ref[, c("median_ERpos", "median_ERneg", "median_hcfDNA")]
median_ref=median_ref[common_dmr, ]
colnames(median_ref) = gsub('median_', '', colnames(median_ref))

dmr_beta=dmr_beta[common_dmr, ]

median_ref=median_ref[order(row.names(median_ref)), ]
dmr_beta=dmr_beta[order(row.names(dmr_beta)), ]

head(median_ref)
head(dmr_beta)

median_ref=as.matrix(median_ref)
dmr_beta=as.matrix(dmr_beta)

### Run EpiDISH
out_epidish=EpiDISH::epidish(beta.m = dmr_beta, ref.m = median_ref, method = "RPC")$estF

out_epidish=as.data.frame(out_epidish)
head(out_epidish)

out_epidish$er_status_pred=dplyr::case_when(
  out_epidish$hcfDNA==1 ~ 'hcfDNA',
  out_epidish$ERpos>=out_epidish$ERneg ~ 'ERpos',
  out_epidish$ERpos<out_epidish$ERneg ~ 'ERneg'
)

table(out_epidish$er_status_pred, useNA = 'always')

saveRDS(out_epidish, file.path(path_out, 'RPC_components.rds'))

```
